<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <link rel="stylesheet" type="text/css" href="style_reset.css">
  <link rel="stylesheet" type="text/css" href="style.css">
  <title>G.R.L: Groot's Runtime Library</title>
 </head>
 <body>

  <h1 class="page">G.R.L.: Groot's Runtime Library</h1>

  <h2>Table Of Contenst:</h2>

  <ol>
   <li><a href="index.htm">About G.R.L.</a></li>
   <li><a href="#compile" >How to compile GRL library</a></li>
   <li><a href="#link"    >How to compile with GRL libary</a></li>
   <li><a href="#use"     >How to use GRL library</a></li>
   <li><a href="#baseType">Base types</a></li>
   <ol>
    <li><a href="#Gb"    >Gb (Boolean)</a></li>
    <li><a href="#Gi"    >Gi (Signed Integer), Gn (Unsigned Integer), Gr (Real)</a></li>
    <li><a href="#Gcount">Gcount, Gindex, Goffset, Gsize</a></li>
   </ol>
  </ol>

  <!---------------------------------------------------------------------------------------------->
  <a name"compile"><h1>How to compile GRL library </h1></a>
  <p>
   I do not use helpers like CMake.  Mainly because I have not found one that is not annoying
   to me on some way.  So with this project there will be a...
  </p>
  <ul>
   <li>Visual Studio project(s) for a Windows compile.</li>
   <li>XCode project for OSX compiles (once done)</li>
   <li>Make file(s) or whatever for *NIX compiles (once done)</li>
  </ul>
  <p>
   Find the appropriate solution for you and compile.
  </p>
  <p>
   The library compiles to a static library instead of a DLL or shared library.  If you want a DLL
   or shared libary then you will have to do the work yourself.  I like to keep my life simple and
   just use static libraries as there is less pain involved when it comes time to release.
  </p>
  <p>
   When you build the library you will need to provide some compile time defines.
  </p>
  <ul>
   <li>
    <strong>grlWINDOWS, grlOSX, or glrUNIX</strong>, needs to be defined so that proper platform
    code is compiled for the libary.
   </li>
   <li>
    <strong>grl32 or grl64</strong>, needs to be defined so that the proper architecture code is
    compiled for the library.
   </li>
   <li><strong>grlSWAP</strong>, needs to be defined on little endian machines.</li>
  </ul>

  <h2>g_config.h</h2>
  <p>
   In the source file g_config.h there are some flags at the top that you may wish to set for 
   different code to be compiled in.
  </p>

  <h3>GCHECK_MEMORY_IS_ON</h3>
  <p>
   Set this to 1 if you want at every dynamic memory (gmemCreate and gmemDestroy and related) call
   a check on the sanity of the heap to be done.  On Windows this is a CRT function call.  
  </p>
  <p>
   You would use this if you are experiencing heap corruption and wanting to find out who might be
   corrupting the heap or at least narrow it down to when the Heap was good to when it became bad in
   an effort to narrow down your search.
  </p>

  <h3>GTRACE_IS_ON</h3>
  <p>
   Function tracing.  This is mean to dump to a file the code flow.  The file will hold almost all
   of the functions that were called assuming genter and greturn* were used in the code.
  </p>

  <h3>GMEM_INCLUDES_TYPE_STRING</h3>
  <p>
   Dynamic memory creations (gmemCreate* calls) often include a 'type' string.  This string is 
   stored with the dynamic memory in debug by default.  Sometimes this comes in handy when you are
   dealing with baffling dynamic memory pointer issues.
  </p>

  <!---------------------------------------------------------------------------------------------->
  <a name"link"><h1>How to compile with GRL library</h1></a>
  <p>
   When you build your project and you intend to use this library, you will need to provide some
   compile time defines.
  </p>
  <ul>
   <li>
    <strong>grlWINDOWS, grlOSX, or glrUNIX</strong>, needs to be defined so that proper platform
    code is compiled for the libary.
   </li>
   <li>
    <strong>grl32 or grl64</strong>, needs to be defined so that the proper architecture code is
    compiled for the library.
   </li>
   <li><strong>grlSWAP</strong>, needs to be defined on little endian machines.</li>
  </ul>
  <p>
   Add the grl.lib and grl include path to your build.
  </p>

  <!---------------------------------------------------------------------------------------------->
  <a name="use"><h1>How to use</h1></a>
  <p>
   Add to your source file(s) the grl include...
  </p>
  <pre class="code">#include "grl.h"
</pre>

  <p>
   At your program start you need to call...
  </p>
  <pre class="code">if (!grlStart())
{
   // Failed to start GRL.  Shutdown.
}
</pre>
  <p>
   grlStart() will set up internal states of the library.  Failure to do this will cause problems.
  </p>

  <p>
   At your program exit you should call...
  </p>
  <pre class="code">grlStop();
</pre>
  <p>
   grlStop() will display debug information like a leak report if you are doing leak checking with
   GRL.  It is not strictly necessary to call but it would be a wise thing to do in my opinion.
  </p>

  <!---------------------------------------------------------------------------------------------->
  <a name="baseType"><h1>Base types</h1></a>

  <a name="Gb"><h2>Gb (Boolean)</h2></a>
  <pre class="code">typedef enum
{
   gbFALSE              =  0,
   gbTRUE               =  1,
   gbUNDEFINED          = -1
} Gb;</pre>
  <p>
   Yes stdbool.h is a thing now for C but this was predating that.  GRL uses the above for boolean
   results.  UNDEFINED is rarely used and whatever uses UNDEFINED should explicitely say so.  
   Otherwise assume it is not a possibility.
  </p>

  <a name="Gi"><h2>Gi (Signed Integer), Gn (Unsigned Integer), Gr (Real)</h2></a>
  <pre class="code">typedef int8_t             Gi1;
typedef int16_t            Gi2;
typedef int32_t            Gi4;
typedef int64_t            Gi8;
typedef uint8_t            Gn1;
typedef uint16_t           Gn2;
typedef uint32_t           Gn4;
typedef uint64_t           Gn8;
typedef float              Gr4;
typedef double             Gr8;
</pre>
  <p>
   As you can see I am using the stdint types.  I believe when I was starting out with GRL it was
   not really common yet and I was using standard C types.  I could be wrong.  But like any other 
   library, I define my own types based on memory size.  Instead of bits I use byte count.  
  </p>
  <p>
   <strong>i</strong> - Integer type.  (Signed integers)<br />
   <strong>n</strong> - Natural type and 0.  (Unsigned integers)<br />
   <strong>r</strong> - Real type.  (Floating point numbers)
  </p>
  <pre class="code">typedef void               Gp;
typedef Gi8                Gi;
typedef Gn8                Gn;
typedef Gr8                Gr;
  </pre>
  <p>
   Same as the above but the numberless versions represent the largest possible representation of
   the type for the platform.  Which may not be the most efficient form for the types.
  </p>
  <pre class="code">typedef intptr_t           Gip;
typedef uintptr_t          Gnp;
</pre>
  <p>
   Pointer sized versions of integer and natural.
  </p>
  <pre class="code">typedef Gi4                Gih;
typedef Gn4                Gnh;
typedef Gr8                Grp;
</pre>
  <p>
   Half size versions for the platform.
  </p>

  <pre class="code">#define GnMAX                 Gn8MAX
#define GiMAX                 Gi8MAX
#define GrMAX                 Gr8MAX
#define GrMIN                 Gr8MIN

#define Gi1MAX                INT8_MAX
#define Gi1MIN                INT8_MIN
#define Gi2MAX                INT16_MAX
#define Gi2MIN                INT16_MIN
#define Gi4MAX                INT32_MAX
#define Gi4MIN                INT32_MIN
#define Gi8MAX                INT64_MAX
#define Gi8MIN                INT64_MIN

#define Gn1MAX                UINT8_MAX
#define Gn2MAX                UINT16_MAX
#define Gn4MAX                UINT32_MAX
#define Gn8MAX                UINT64_MAX

#define Gr4MAX                FLT_MAX
#define Gr4MIN                FLT_MIN
#define Gr8MAX                DBL_MAX
#define Gr8MIN                DBL_MIN

#define GnpMAX                UINTPTR_MAX
#define GipMAX                INTPTR_MAX
</pre>
  <p>
   The limit constants for these types.  Not complete when it comes to Reals but I have not needed
   the other constants just yet.
  </p>

  <a name="Gcount"><h2>Gcount, Gindex, Goffset, Gsize</h2></a>
  <pre class="code">typedef Gi4                Gcount;
typedef Gi4                Gindex;
typedef Gi4                Goffset;
typedef Gi4                Gsize;
</pre>
  <p>
   These are common integer/natural types used in a lot of places.  These will be the most efficient
   size for the platform and currently are integers and not naturals.  I initially tried naturals
   but for some things, like offset, you need negative numbers.  For simplicity I kepts them 
   integers.  If you end up in a situation where the efficient size integers is not enough range 
   then you will have to do something else.
  </p>
  <p>
   Why not just use the raw integer type?  Well, sometimes the type adds to the description of the
   variable/parameter.  In this case, if I have a funciton that expects an offset then it is clear
   what that variable intends to do.  You may not need to even look at the name of the variable.
   So I use it as a form of making the code more clear.
  </p>

  <pre class="code">#define GcountMAX             Gi4MAX

#define GindexERROR           Gi4MIN
#define GindexMAX             Gi4MAX

#define GoffsetMAX            Gi4MAX
#define GoffsetMIN            Gi4MIN

#define GsizeMAX              Gi4MAX
</pre>
  <p>
   The limit constants for these types.  
  </p>

 </body>
</html>