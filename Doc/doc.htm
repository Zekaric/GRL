<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <link rel="stylesheet" type="text/css" href="style_reset.css">
  <link rel="stylesheet" type="text/css" href="style.css">
  <title>G.R.L: Groot's Runtime Library</title>

  <!-- Script for generation a table of contents -->
  <script>
const indexLEVEL     = 0;
const indexTAG       = 1;
const indexTITLE     = 2;
const indexHAS_TYPE  = 3;
const indexHAS_CONST = 4;
const indexHAS_FUNC  = 5;
const indexCOUNT     = 6;

var tocIndex = 0;
var toc      = [];

// Display a header line and add to the table of contents (TOC)
function HeaderAdd(level, tag, title)
{
   var record = [];
   
   record[indexLEVEL]     = level;
   record[indexTAG]       = tag;
   record[indexTITLE]     = title;
   record[indexHAS_TYPE]  = false;
   record[indexHAS_CONST] = false;
   record[indexHAS_FUNC]  = false;

   toc.push(record);

   // Chrome complains about this document write.  I have looked for an alternative but everything
   // I have found is utter rubbish.  HeaderAdd is only called on doc load.  This call is not a
   // problem.
   document.write("<h" + level + "><a name=\"" + tag + "\">" + title + "</a></h" + level + ">\n\n");
}

function HeaderAddType()
{
   var record = toc[toc.length - 1];

   record[indexHAS_TYPE] = true;

   document.write("<h2><a name=\"" + record[indexTAG] + "Type\">Type</a></h2>\n\n");
}

function HeaderAddConst()
{
   var record = toc[toc.length - 1];

   record[indexHAS_CONST] = true;

   document.write("<h2><a name=\"" + record[indexTAG] + "Const\">Constant</a></h2>\n\n");
}

function HeaderAddFunc()
{
   var record = toc[toc.length - 1];

   record[indexHAS_FUNC] = true;

   document.write("<h2><a name=\"" + record[indexTAG] + "Func\">Function</a></h2>\n\n");
}

// Update the TOC with all the header lines.
function UpdateToc()
{
   var value;
   var record;
   var index;

   value = "<table>\n";

   for (; tocIndex < toc.length; tocIndex++)
   {
      record     = toc[tocIndex];
    
      value += "<tr>\n<td>";
    
      // Indenting
      for (index = 1; index < record[0]; index++)
      {
         value += "&nbsp;&nbsp;&nbsp;&nbsp;";
      }

      value += "<a href=\"#" + record[1] + "\">" + record[2] + "</a></td>\n";
      
      value += "<td>";
      if (record[indexHAS_TYPE] == 1)
      {
         value += "<a href=\"#" + record[1] + "Type\">Type</a>\n";
      }
      value += "</td>\n";
      
      value += "<td>";
      if (record[indexHAS_CONST] == 1)
      {
         value += "<a href=\"#" + record[1] + "Const\">Constant</a>\n";
      }
      value += "</td>\n";

      value += "<td>";
      if (record[indexHAS_FUNC] == 1)
      {
         value += "<a href=\"#" + record[1] + "Func\">Function</a>\n";
      }
      value += "</td>\n";

      value += "</td>\n";
   }

   value += "</table>\n";

   document.getElementById("toc").innerHTML = value;
}
  </script>
 </head>
 <body>
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <h1 class="page">G.R.L.: Groot's Runtime Library</h1>

  <p>
   This doc is in development so it will change quite a lot from update to update.  I am using
   Visual Studio for editing the doc.  Tabs are 4 but indents are 1 and spaces instead of tabs.
  </p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <h2>Table Of Contenst:</h2>

  <p id="toc"></p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "about", "About G.R.L.");</script>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "aboutDesc", "Description");</script>

  <p>G.R.L. (Girl) is a C kitchen sink library to make development easier.</p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "aboutHist", "History");</script>

  <p>
   I joined a company back in 1995 that created software for Sun OS, Sun Solaris, SGI Irix, and
   Window NT 3.XX. In order for them to do that they used a cross platform library called Galaxy
   which was owned by a company called Visix. A little time after Java came on to the scene and a
   Visix thought that was going to be the future of cross platform development. They let Galaxy
   stagnate and focused on a Java product they developed. Moving on a few years the Java product
   did not sell well (I believe, no facts to back it up) and their bread and butter clients using
   Galaxy were moving on as their products were becoming stagnant because Galaxy was not keeping
   up with the times. Visix just decided to pack up and quit.
  </p>

  <p>
   Galaxy is now owned by a Brazilian company called Ambiencia which appeared to have no interest
   in supporting any of the existing clients (without the clients to pay for yet another round
   of licensing to them even though a lot already paid a lot to Visix) and so essentially killed
   any chance for Galaxy to move on. It is still around but no one should use it anymore in my
   opinion. QT, Microsoft's WPF, Xamarin, and others have surpassed Galaxy.
  </p>

  <p>
   QT did exist at the same time when the company was looking for a cross platform library but it
   was very small back then and not as complete as Galaxy was. Plus C++ compilers back then were
   not the same quality from platform to platform. Also the developers the company had already,
   mostly FORTRAN programmers, would have a harder jump to C++ than to C.  Or at least that was
   the feeling at the time.
  </p>

  <p>
   This left us in a bit of a lurch. So on a whim, back in and around 2000, I started to make a
   kitchen sink library to replace Galaxy on my own time at home, in the hopes it would be adopted
   by the company. It never was.  They opted to move to C++ and its standard library instead.
   However, I use this library in my hobby coding so I still continue with the development of the
   library.  This library has gone through a couple of iterations as I was playing with a few ideas
   which some just did not work out.
  </p>

  <p>
   Why not just wrap C++ stdlib for this work instead of writing everything again in C?  That is
   also an option when doing something like this.  I did not do it that way because I am not a big
   fan of C++.  I also like control.  I want to be able to tweak the implementation and not leave
   it in someone else's hands.  Yeah, yeah, reinventing the wheel.  But sometimes it is necessary
   to be happy.
  </p>

  <p>
   Initially GRL stood for "Galaxy Replacement Library" but since it was not going to be doing that
   in reality, I just decided to rebrand it (de) "Groot's Runtime Library".  For the longest time I
   wanted to hopefully make money of this code but in my opinion that time has long since past.  So
   I decided to make it free for use.
  </p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "aboutLic", "License");</script>

  <pre>
BSD 2-Clause License

Copyright (c) 2000, Robbert de Groot
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</pre>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "aboutGoal", "Goals");</script>

  <ul>
   <li>
    Kitchen sink library.  It should do 'almost' everything you need for development.
   </li>
   <li>
    Simplify API.  Some tasks networking with socket IO I find has an odd API or unknown gotchas
    that you will only find out once you hit them or have carefully read the fine detail in the
    documentation.  I would like to get rid of as much of those gotchas as possible.
   </li>
   <li>
    Cross platform.  Currently failing here because I am only adding to the library when the need
    arrises.  OSX and *NIX OSes will eventually come but currently, I spend most of my life in
    WINDOWS.
   </li>
   <li>
    Performance.  The library should not really slow you down in terms of coding or in terms of
    run time.  There are always going to be some compromises but for the most part it should be
    out of the way and not causing grief.
   </li>
  </ul>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "compileLib", "How to compile GRL library");</script>

  <p>
   I do not use helpers like CMake.  Mainly because I have not found one that is not annoying
   to me on some way.  So with this project there will be a...
  </p>

  <ul>
   <li>Visual Studio project(s) for a Windows compile.</li>
   <li>XCode project for OSX compiles (once done)</li>
   <li>Make file(s) or whatever for *NIX compiles (once done)</li>
  </ul>

  <p>
   Find the appropriate solution for you and compile.
  </p>

  <p>
   The library compiles to a static library instead of a DLL or shared library.  If you want a DLL
   or shared libary then you will have to do the work yourself.  I like to keep my life simple and
   just use static libraries as there is less pain involved when it comes time to release.
  </p>

  <p>
   When you build the library you will need to provide some compile time defines.
  </p>

  <ul>
   <li>
    <strong>grlWINDOWS, grlOSX, or glrUNIX</strong>, needs to be defined so that proper platform
    code is compiled for the libary.
   </li>
   <li>
    <strong>grl32 or grl64</strong>, needs to be defined so that the proper architecture code is
    compiled for the library.
   </li>
   <li><strong>grlSWAP</strong>, needs to be defined on little endian machines.</li>
  </ul>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "conpileLibGconfig", "g_config.h");</script>

  <p>
   In the source file g_config.h there are some flags at the top that you may wish to set for
   different code to be compiled in.
  </p>

  <!---------------------------------------------------------------------------------------------->
  <h3>GCHECK_MEMORY_IS_ON</h3>

  <p>
   Set this to 1 if you want at every dynamic memory (gmemCreate and gmemDestroy and related) call
   a check on the sanity of the heap to be done.  On Windows this is a CRT function call.
  </p>

  <p>
   You would use this if you are experiencing heap corruption and wanting to find out who might be
   corrupting the heap or at least narrow it down to when the Heap was good to when it became bad in
   an effort to narrow down your search.
  </p>

  <!---------------------------------------------------------------------------------------------->
  <h3>GMEM_INCLUDES_TYPE_STRING</h3>

  <p>
   Dynamic memory creations (gmemCreate* calls) often include a 'type' string.  This string is
   stored with the dynamic memory in debug by default.  Sometimes this comes in handy when you are
   dealing with baffling dynamic memory pointer issues.
  </p>

  <!---------------------------------------------------------------------------------------------->
  <h3>GTRACE_IS_ON</h3>

  <p>
   Function tracing.  This is mean to dump to a file the code flow.  The file will hold almost all
   of the functions that were called assuming genter and greturn* were used in the code.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "compileExe", "How to compile with GRL library");</script>

  <p>
   When you build your project and you intend to use this library, you will need to provide some
   compile time defines.
  </p>

  <ul>
   <li>
    <strong>grlWINDOWS, grlOSX, or glrUNIX</strong>, needs to be defined so that proper platform
    code is compiled for the libary.
   </li>
   <li>
    <strong>grl32 or grl64</strong>, needs to be defined so that the proper architecture code is
    compiled for the library.
   </li>
   <li><strong>grlSWAP</strong>, needs to be defined on little endian machines.</li>
  </ul>

  <p>
   Add the grl.lib and grl include path to your build.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "use", "How to use GRL library");</script>

  <p>
   Add to your source file(s) the grl include...
  </p>

  <pre>
#include "grl.h"
</pre>

  <p>
   At your program start you need to call...
  </p>

  <pre>
if (!grlStart())
{
   // Failed to start GRL.  Shutdown.
}
</pre>

  <p>
   grlStart() will set up internal states of the library.  Failure to do this will cause problems.
  </p>

  <p>
   At your program exit you should call...
  </p>

  <pre>
grlStop();
</pre>

  <p>
   grlStop() will display debug information like a leak report if you are doing leak checking with
   GRL.  It is not strictly necessary to call but it would be a wise thing to do in my opinion.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "style", "Style");</script>

  <p>
   I use a particular style with GRL and my own coding.  With this style is makes identifying what
   something is fairly easily.
  </p>

  <p>
   Naming convention being used.
  </p>

  <pre>
Program Global:
Constant:        prefixTypeNameCONSTANT_VALUE
Type:            PrefixTypeName
Variable:        [There are none.  Use a module global and a function to manipulate it.]
Function:        prefixFuncionName()

Libary Global:
Function:        _prefixFunctionName

Module Global:
Variable:        static ... _variableName
Function:        static ... _FunctionName

Function Levle:
Varaible:        variableName
</pre>

  <p>
   prefix being a string that identifies what part of the code it belongs to.  like glist for
   linked lists for example.
  </p>

  <p>
   The capitalization is important.  I dislike the use of '_' because I find it annoying to type so
   I heavily use CamelCasing to differentiate the words in a name.  Starting letter may or may not
   be capitalized and it is specific to usage.
  </p>

  <p>
   The idea is that by just by looking at a name of something you should be able to tell the scope
   of what you are looking at without having to find our where it was actually defined.
  </p>

  <p>
   Also on a little of the OCD side, I organize the C files so that I have sections, in order,
   includes, constants, types, variables, local function prototypes, global function definitions,
   local function definitions.  Simlar H files are ordered, includes (if needed), constants, types,
   and glocal function prototypes.
  </p>

  <p>
   Indents are 3.<br />
   I line up =, logic ops, parameters on mulitple lines, etc.<br />
   I never have an assignment in a conditional, which means I write x == 0 instead of 0 == x.<br />
   Logic statements have the logic op at the end (not at the beginning) using reverse indentation.<br />
   Code is paragraphed.<br />
   etc.
  </p>








  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "macro", "Macroes");</script>

  <p>
   You may find some or all of these macroes curious or infuriating.  I use them for the reason of
   better code readability (subjective I know) and better coding experience, reducing tired
   programmer mistakes and related.  You do not have to use any of these but I use them a lot in
   my own coding.
  </p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "breakIf", "breakIf()");</script>
  <pre>
#define breakIf(C)         if ((C)) { break; }
</pre>

  <p>
   Loop control wrappers for common patterns.  Makes for easier to read code in my opinion and
   slightly less typing.
  </p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "continueIf", "continueIf()");</script>
  <pre>
#define continueIf(C)      if ((C)) { continue; }
</pre>

  <p>
   Loop control wrappers for common patterns.  Makes for easier to read code in my opinion and
   slightly less typing.
  </p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "debugHalt", "debugHalt*()");</script>

  <pre>
#define debugHalt(STRING)           /*lint -save -e944 -e917 -e920 -e960 -e9008 -e9007 */ assert(gbFALSE && (STRING)) /*lint -restore */
#define debugHaltIf(VALUE, STRING)  if (VALUE) { debugHalt(STRING); }
</pre>

  <p>
   Halt is calling assert().  I just find it easier to read than using the assert() function call.
  </p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "debugCheckMemory", "debugCheckMemory()");</script>

  <pre>
#define debugCheckMemory()    _CrtCheckMemory();
</pre>

  <p>
   CheckMemory will test the dynamic heap for corruption.  This can be handy when trying to find
   memory corruption.  Sprinkle these functions around your code where you think the corruption
   may be happening.
  </p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "debugPrint", "debugPrint()");</script>

  <pre>
#define debugPrint(WSTR)            OutputDebugString(WSTR)
</pre>

  <p>
   Print will print a wchar_t * string to the output window in case of Visual Studio on Windows.
   Nothing specific for OSX and Linux yet.
  </p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "for", "for*(), loop*()");</script>

  <pre>
#define forCount(INDEX, COUNT)      for ((INDEX) = 0;           (INDEX) <  (COUNT); (INDEX) += 1)
#define forCountDown(INDEX, COUNT)  for ((INDEX) = (COUNT) - 1; (INDEX) >= (COUNT); (INDEX) -= 1)
#define loop                        for (;;)
#define loopCount(INDEX)            for ((INDEX) = 0;            ; (INDEX) += 1)
#define loopOnce                    for (int __index__ = 0; __index__ < 1; __index__++)
</pre>

  <p>
   Wrappers for loops.  You may find these curious but I find these save me some headaches as they
   reduce errors like bad increment and such.  Plus I find they are easier to read.
  </p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "gotoIf", "gotoIf(), stopIf()");</script>

  <pre>
#define gotoIf(C,G)        if ((C)) { goto G; }
#define stopIf(C)          if ((C)) { goto STOP; }
</pre>

  <p>
   Wrappers for goto calls.  If you need to use these, use them sparingly and only forward jumps
   to a equal or higher level scope.  Do not jump into another scope.  Sometimes it is useful for
   simple exception like handling.  Stop if will jump to the label STOP.
  </p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "return", "return*()");</script>

  <pre>
#define returnIf(C,V)      if ((C)) { return (V); }
#define return0If(C)       if ((C)) { return 0; }
#define return1If(C)       if ((C)) { return 1; }
#define returnVoidIf(C)    if ((C)) { return; }
#define returnNullIf(C)    if ((C)) { return NULL; }
#define returnTrueIf(C)    if ((C)) { return gbTRUE; }
#define returnFalseIf(C)   if ((C)) { return gbFALSE; }
</pre>

  <p>
   Basic return equivalents to greturn.  These do not call greturn and so are not paired with
   genter.
  </p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "genter", "genter, greturn");</script>

  <pre>
#if 0 // kept in case I need to revisit.
#if   (GPROFILE_IS_ON == 1) && (GTRACE_IS_ON == 1)

#define genter \
   static Gindex ___profIndex___ = -1;\
   Gtime         ___profTime___  = gprofileEnter(&___profIndex___, __FILE__, __FUNCTION__);\
   gtraceEnter();

#elif GPROFILE_IS_ON == 1

#define genter \
   static Gindex ___profIndex___ = -1;\
   Gtime         ___profTime___  = gprofileEnter(&___profIndex___, __FILE__, __FUNCTION__);

#elif GTRACE_IS_ON == 1
#endif
#endif

#if GTRACE_IS_ON == 1

#define genter \
   gtraceEnter()

#else

#define genter 

#endif

// Return macroes
// Complements the enter macroes and is called on exit of a function.
#if 0
#if   (GPROFILE_IS_ON == 1) && (GTRACE_IS_ON == 1)

#define greturn \
   gtraceExit();\
   gprofileExit(___profIndex___, ___profTime___);\
   return

#elif GPROFILE_IS_ON == 1

#define greturn \
   gprofileExit(___profIndex___, ___profTime___);\
   return

#elif GTRACE_IS_ON == 1
#endif
#endif

#if GTRACE_IS_ON == 1

#define greturn \
   gtraceExit();\
   return

#else

#define greturn \
   return

#endif
</pre>

  <p>
   I have always wanted a way to add common code to the entry of the function and to the exit of a
   function.  Unfortunately there is no nice way to do this.  So all the higher level code that I
   write includes a genter and greturn macroes.  This way I can do what I want on entry and exit.
  </p>

  <p>
   Things I have tried:
  </p>

  <ul>
   <li>
    Profiler code - For a time there was not any free profilers so I added some code to do that.
    Unfortunately it was not threadable but for the times I needed it it was useful.  Fortunately
    there are a few good free ones available now like, MicroProfiler, Sleepy, etc. so my code is
    no longer necessary.
   </li>
   <li>
    Tempory data cleanup - At one point I played with the idea of keeping track temporary dynamically
    allocated data that would automatically cleanup at function exit.  Unfortunately it was not that
    clean and added a bit more code smell so I felt it was not really worth it.
   </li>
   <li>
    I still have include function tracing.  Which unfortunately does not work well in a multi-
    threaded environment.  Works well in a single threaded program and what happens is that every
    function entry will be recorded in a trace file.
   </li>
  </ul>

  <p>
   Those are some of the reasons I was using genter and greturn.  I keep them around just in case
   another need arrises.
  </p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "greturn", "greturn*()");</script>

  <pre>
#define greturnIf(C,V)     if ((C)) { greturn (V); }
#define greturn0If(C)      if ((C)) { greturn 0; }
#define greturn1If(C)      if ((C)) { greturn 1; }
#define greturnVoidIf(C)   if ((C)) { greturn; }
#define greturnNullIf(C)   if ((C)) { greturn NULL; }
#define greturnTrueIf(C)   if ((C)) { greturn gbTRUE; }
#define greturnFalseIf(C)  if ((C)) { greturn gbFALSE; }
</pre>

  <p>
   Wrappers for common greturn cases.  Makes for easier to read code in my opinion and slightly less
   typing.  These call greturn while matches genter.
  </p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "gsizeof", "gsizeof()");</script>

  <pre>
#define gsizeof(V)         ((Gsize) sizeof(V))
</pre>

  <p>
   Wrapper for sizeof function.
  </p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "gpHash", "gpHash()");</script>

  <pre>
#define gpHash(P) ((GhashN) ((((Gnp) P) / 4) % GhashNMAX))
</pre>

  <p>
   A basic function for hashing a pointer.  This is assuming pointers are 4 byte aligned.
  </p>










  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "API", "API");</script>

  <p>
   Like a lot of C libraries I have defined my own types just to address the problem that C's base
   integer types are not strictly of a certain size.  Or there are missing types like boolean.
  </p>

  <p>
   Granted newer updates to C have tried to rectify the situation but maybe a little too late.
   Plus I dislike typeing '_' but will use it only for constants for historical reasons.  So all
   the new types like wchar_t, int16_t, etc.  God I hate that '_'.  It slows down typing in my
   opinion and does not really improve readability in my opinion.
  </p>

  <p>
   Also other API that do not include a specific type but more a module for some purpose.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "grl", "grl");</script>

  <script>HeaderAddFunc();</script>

  <pre>
grlAPI Gpath   *grlGetExePath(   void);
</pre>
  <p>
   Get the path to the exe file.
  </p>
  <pre>
grlAPI Gb       grlIsStarted(    void);
</pre>
  <p>
   Is the grl library initialized and ready.
  </p>

  <pre>
grlAPI Gb       grlSetExePath(   Gpath * const path);
</pre>
  <p>
   Set the exe file path.  Not usually called by you.  The exe path is set on program start.
  </p>

  <pre>
grlAPI Gb       grlStart(        void);
</pre>
  <p>
   Start the grl library.
  </p>

  <pre>
grlAPI void     grlStop(         void);
</pre>
  <p>
   Stop the grl library.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "Char", "Char, Uchar");</script>

  <pre>
typedef signed char        Char;
typedef unsigned char      Uchar;
</pre>

  <p>
   Not usually types I use.  However I define these because I am using PCLint program to keep the
   code somewhat clean of issues.  One of the things with PCLint is that it warns about using char
   and unsigned char so I have these defined to avoid the issue.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "Galignment", "Galignment");</script>

  <pre>
typedef enum
{
   galignmentDEFAULT    = 0,

   galignmentH_LEFT     = 0x10000000,
   galignmentH_CENTER   = 0x01000000,
   galignmentH_FILL     = 0x00100000,
   galignmentH_RIGHT    = 0x00010000,

   galignmentV_TOP      = 0x00001000,
   galignmentV_CENTER   = 0x00000100,
   galignmentV_FILL     = 0x00000010,
   galignmentV_BOTTOM   = 0x00000001,

   galignmentH_MASK     = 0xFFFF0000u,
   galignmentV_MASK     = 0x0000FFFF
} Galignment;
</pre>

  <p>
   Various functions require defining an alignment in the horizontal and vertical directions.  Trying
   to define one type to cover them all.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "Gb", "Gb (Boolean)");</script>

  <pre>
typedef enum
{
   gbFALSE              =  0,
   gbTRUE               =  1,
   gbUNDEFINED          = -1
} Gb;
</pre>

  <p>
   Yes stdbool.h is a thing now for C but this was predating that.  GRL uses the above for boolean
   results.  UNDEFINED is rarely used and whatever uses UNDEFINED should explicitely say so.
   Otherwise assume it is not a possibility.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "Gbit", "Gbit");</script>

  <pre>
typedef unsigned int       Gbit;
</pre>

  <p>
   This is specific to bit fields in a struct.  Because every time using standard C types, I
   forget the "unsigned" keyword.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "Gcompare", "Gcompare");</script>

  <pre>
typedef enum
{
   gcompareLESS_THAN    = -1,
   gcompareEQUAL        =  0,
   gcompareGREATER_THAN =  1,
   gcompareUNKNOWN      =  2
} Gcompare;
</pre>

  <p>
   Defining the result for all compare functions.  I do not remember why I have UNKNOWN and for the
   most part it is never used.  But like Gb and UNDEFINED, if a function returns UNKNOWN it should
   be made very clear.  I may remove it in the future.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "Gcount", "Gcount");</script>

  <script>HeaderAddType();</script>

  <pre>
typedef Gi4                Gcount;
</pre>

  <p>
   A common integer/natural type used in a lot of places.  This will be the most efficient
   size for the platform and currently is an integer and not a natural.  I initially tried a
   natural but for some things, you need negative numbers.  For simplicity I kept it an integer.
   If you end up in a situation where the efficient size integer is not enough range then you will
   have to do something else.
  </p>

  <p>
   Why not just use the raw integer type?  Well, sometimes the type adds to the description of the
   variable/parameter.  In this case, if I have a function that expects an offset then it is clear
   what that variable intends to do.  You may not need to even look at the name of the variable.
   So I use it as a form of making the code more clear.
  </p>

  <script>HeaderAddConst();</script>

  <pre>
#define GcountMAX             Gi4MAX
</pre>

  <p>
   The limit constants for these types.
  </p>

  <script>HeaderAddFunc();</script>

  <pre>
#define gcountIsGood(C)    (0 <= (C))
</pre>

  <p>
   IsGood check for a gcount.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "Gguid", "Gguid");</script>

  <p>
   GUID type wrapper.  Using system calls to handle GUIDs.
  </p>

  <script>HeaderAddType();</script>

  <pre>
typedef struct
{
   Gn8             n[2];
   Gn1             b[16];
} Gguid;
</pre>

  <script>HeaderAddFunc();</script>

  <pre>
grlAPI void     gguidCreateContent(       Gguid * const guid);
</pre>

  <p>
   Wrapper of OS routines for Initializing the contents of a GUID with a new unique GUID value.
  </p>

  <pre>
grlAPI void     gguidCreateContentFromA(  Gguid * const guid, Char const * const string);
</pre>

  <p>
   Initialize a Gguid from a char string representation of a GUID.
  </p>

  <pre>
grlAPI Gb       gguidIsEqual(             Gguid const a, Gguid const b);
</pre>

  <p>
   Test two guids for equality.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "GhashN", "GhashN");</script>

  <pre>
typedef Gn4                GhashN;
</pre>

  <p>
   The data type that all hash functions will return.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "GheapN", "GheapN");</script>

  <pre>
typedef Gn4                GheapN;
</pre>

  <p>
   The data type that all heaps will use.  Currently only the Gtree uses this.  See Gtree
   implementation.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "Gi", "Gi (Integer)");</script>

  <script>HeaderAddType();</script>
  <pre>
typedef int8_t             Gi1;
typedef int16_t            Gi2;
typedef int32_t            Gi4;
typedef int64_t            Gi8;
</pre>

  <p>
   As you can see I am using the stdint types.  I believe when I was starting out with GRL it was
   not really common yet and I was using standard C types.  I could be wrong.  But like any other
   library, I define my own types based on memory size.  Instead of bits I use byte count.
  </p>

  <pre>
typedef Gi8                Gi;
</pre>

  <p>
   Same as the above but the numberless versions represent the largest possible representation of
   the type for the platform.  Which may not be the most efficient form for the types.
  </p>

  <pre>
typedef intptr_t           Gip;
</pre>

  <p>
   Pointer sized versions of integer and natural.
  </p>

  <pre>
typedef Gi4                Gih;
</pre>

  <p>
   Half size versions for the platform.
  </p>

  <script>HeaderAddConst();</script>

  <pre>
#define GiMAX                 Gi8MAX

#define Gi1MAX                INT8_MAX
#define Gi1MIN                INT8_MIN
#define Gi2MAX                INT16_MAX
#define Gi2MIN                INT16_MIN
#define Gi4MAX                INT32_MAX
#define Gi4MIN                INT32_MIN
#define Gi8MAX                INT64_MAX
#define Gi8MIN                INT64_MIN

#define GipMAX                INTPTR_MAX
</pre>

  <p>
   The limit constants for these types.  Not complete when it comes to Reals but I have not needed
   the other constants just yet.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "Gid", "Gid");</script>

  <script>HeaderAddType();</script>

  <pre>
typedef Gn4                Gid;
</pre>

  <p>
   Simpler than a Gguid.  The uniqueness of an id is left to the programmer.
  </p>

  <script>HeaderAddFunc();</script>

  <pre>
#define gidGetN(ID)        ((Gn4) ID)
</pre>
  <p>
   Return the natural value of the id. <br />
  </p>

  <pre>
#define gidGetFromN(VALUE) ((Gid) VALUE)
</pre>
  <p>
   Convert a natrual value to an id.<br />
  </p>

  <pre>
#if defined(grlSWAP)
#define gidGetC(ID, CHAR4)                \
   (CHAR4[3] = (Char) (((ID) & 0xff000000) >> 24), \
    CHAR4[2] = (Char) (((ID) & 0x00ff0000) >> 16), \
    CHAR4[1] = (Char) (((ID) & 0x0000ff00) >>  8), \
    CHAR4[0] = (Char) (((ID) & 0x000000ff)))
#else
#define gidGetC(ID, CHAR4)                \
   (CHAR4[0] = (Char) (((ID) & 0xff000000) >> 24), \
    CHAR4[1] = (Char) (((ID) & 0x00ff0000) >> 16), \
    CHAR4[2] = (Char) (((ID) & 0x0000ff00) >>  8), \
    CHAR4[3] = (Char) (((ID) & 0x000000ff)))
#endif
</pre>
  <p>
   Convert an id to a 4 character char string, not NULL terminated.<br />
  </p>

  <pre>
#if defined(grlSWAP)
#define gidGetFromC(CHAR4)                \
   ((CHAR4[3] << 24) |                    \
    (CHAR4[2] << 16) |                    \
    (CHAR4[1] <<  8) |                    \
    (CHAR4[0]))
#else
#define gidGetFromC(VALUE)                \
   ((CHAR4[0] << 24) |                    \
    (CHAR4[1] << 16) |                    \
    (CHAR4[2] <<  8) |                    \
    (CHAR4[3]))
#endif
</pre>
  <p>
   Convert a 4 character char string, not NULL terminated, to an id.<br />
  </p>

  <pre>
#define gidIsEqual(A,B)    ((A) == (B))
</pre>
  <p>
   Compare two ids for equality.<br />
  </p>

  <pre>
#define gidIsGood(I)       (0 < (I))
</pre>
  <p>
   Check if the id is valid.  <br />
  </p>

  <pre>
#define gidIsUndefined(ID) ((ID) == Gn4MAX)
</pre>
  <p>
   Check if the is set to something.<br />
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "Gindex", "Gindex");</script>

  <script>HeaderAddType();</script>

  <pre>
typedef Gi4                Gindex;
</pre>

  <p>
   A common integer/natural type used in a lot of places.  This will be the most efficient
   size for the platform and currently is an integer and not a natural.  I initially tried a
   natural but for some things, you need negative numbers.  For simplicity I kept it an integer.
   If you end up in a situation where the efficient size integer is not enough range then you will
   have to do something else.
  </p>

  <p>
   Why not just use the raw integer type?  Well, sometimes the type adds to the description of the
   variable/parameter.  In this case, if I have a function that expects an offset then it is clear
   what that variable intends to do.  You may not need to even look at the name of the variable.
   So I use it as a form of making the code more clear.
  </p>

  <script>HeaderAddConst();</script>

  <pre>
#define GindexERROR           Gi4MIN
#define GindexMAX             Gi4MAX
</pre>

  <p>
   The limit constants for these types.
  </p>

  <script>HeaderAddFunc();</script>

  <pre>
#define gindexIsGood(I,C)  (0 <= (I) && (I) < (C))
</pre>

  <p>
   IsGood checks for a gindex.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "Gkey", "Gkey");</script>

  <pre>
typedef Gp                 Gkey;
</pre>

  <p>
   The general idea of a key for use in key value pais for the data containers.  A key will always
   be a const pointer.  So uniqueness is the pointer and not necessarily the contents of the pointer.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "GkeyP", "GkeyP");</script>

  <pre>
typedef struct
{
   Gkey const              *key;
   Gp                      *value;
} GkeyP;
</pre>

  <p>
   The basis of a key value pair.  A const pointer for the key and some generic data pointer for
   the value.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "gleak", "gleak");</script>

  <p>
   No types.  Just an API for tracking resource leaks.  Not specifically for memory leaks but is
   used by gmem for dynamic memory leak tracking.
  </p>

  <p>
   Internally gleak code maintains a hash table of leak records.  The hash table is organized as
   bins of linked lists of leak records.  This is reasonably fast in debug.  If not, you may need
   to tweak the hash table size to reduce linked list lengths.
  </p>

  <p>
   gleak is completely disabled in release builds.
  </p>

  <script>HeaderAddFunc();</script>

  <pre>
#define gleakCreate(P,S) gleakCreate_((P), (S), __FILE__, __LINE__)
grlAPI Gp  *gleakCreate_(   Gp * const p, Gsize const size, Char const * const file, Gindex const line);
</pre>
  <p>
   Create a leak record.  If this leak record is not destroyed it will be reported at grlStop().  A
   leak record includes the file and location in the file where the leak occurred.  You would not
   use gleakCreate_() directly, just gleakCreate() macro.  You should call gleakCreate() on the
   same pointer up the call stack.  The last gleakCreate() call will overwrite any previous
   leak record.
  </p>

  <pre>
#define gleakDestroy(P)  gleakDestroy_((P))
grlAPI Gp  *gleakDestroy_(  Gp *p);
</pre>
  <p>
   Destroy a leak record.  This is done when the resource was properly closed, destroyed, or
   whatever needed to happen to it.
  </p>

  <pre>
grlAPI Gb   gleakLockEnter( void);
grlAPI Gb   gleakLockExit(  void);
</pre>
  <p>
   If you have a lot of gleakCreate() calls in rapid succession you may want to call wrap them
   in between a LockEnter and LockExit so that the lock only happens once and the speed of the
   enclosed code will be uninterrupted and fast.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "Glock", "Glock");</script>

  <p>
   Critical Section lock routines.
  </p>

  <p><strong>Example Use:</strong></p>

  <pre>
// Define the lock.
static Glock _lock;

...

// Somewhere on startup.
{
   // Initialize the lock
   glockCreateContent(&_lock);
}

// Somewhere on shutdown.
{
   // Clean up
   glockDestroyContent(&_lock);
}

// Somewhere threaded.
{
   // Entering the critical section.  The thread will halt here if another thread has the lock.
   glockEnter(&_lock);

   // If the thread is executing here then it is the only one executing here.

   // We are done, release the lock.
   glockExit(&_lock);
}

</pre>

  <script>HeaderAddType();</script>
  <pre>
#if grlWINDOWS == 1
typedef CRITICAL_SECTION Glock;
#else
#endif
</pre>

  <p>
   Currently only Windows defined.  I haven't started on any other platforms.
  </p>

  <script>HeaderAddFunc();</script>

  <pre>grlAPI void       glockCreateContent(    Glock * const lock);</pre>
  <p>
   Initializes a lock.
  </p>

  <pre>grlAPI void       glockDestroyContent(   Glock * const lock);</pre>
  <p>
   Clean up a lock.
  </p>

  <pre>grlAPI void       glockEnter(            Glock * const lock);</pre>
  <p>
   Enter a critical section.
  </p>
  <p>
   Code will stop here until the lock is obtained.
  </p>

  <pre>grlAPI void       glockExit(             Glock * const lock);</pre>
  <p>
   Exit a critical section.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "gmem", "gmem");</script>

  <p>
   Dynamic memory functions.  In debug these will make use of gleak for memory leak tracking.
  </p>

  <p>
   In both debug and release, dynamic memory buffers that are 'small' are pooled.  Meaning, if you
   create a bunch of small buffers like the size of 80 bytes.  Then all those buffers when 
   'destroyed' will just be kept around in a pool of buffers that are 80 bytes in size.  When the
   next time the program asks for an 80 byte buffer, the first available buffer from the pool is
   used.
  </p>
  <p>
   Why are we doing this?  Dynamic memory creation and destruction can be slow.  Often causing a
   kernel call which basically locks the system down in order to perform the operation.  If we can
   avoid these calls as much as possible then the speed of the program will be greatly improved.
   At the cost of using some more memory that is.  Reusing a previously allocated buffer is a lot
   quicker than having to free it and then recreate it.
  </p>
  <p>
   Use gmemFlushPools() to reclaim the memory.  Eventually I may add a thread to do the pool 
   flushing but for now this is the responsibility of the programmer.
  </p>

  <script>HeaderAddFunc();</script>

  <pre>
#define memCreate(               BYTECOUNT)                                      calloc((size_t) 1, (size_t) (BYTECOUNT))
#define memCreateType(           TYPE)                                  (TYPE *) memCreate(gsizeof(TYPE))
#define memCreateTypeArray(      TYPE, COUNT)                           (TYPE *) memCreate(gsizeof(TYPE) * (COUNT))
</pre>
  <p>
   Simple wrappers around standard C dynamic memory creation functions.  Not gleak tracked.  
  </p>
  <p>
   CreateType, and CreateTypeArray are convenience functions for making a buffer of a size of a
   type or a buffer of a size of an array of type.  I use these to reduce tired programmer errors
   when writing out dynamic memory creation calls.
  </p>

  <pre>
#define memDestroy(              P)                                              free((Gp *) (P))
</pre>
  <p>
   Freeing the dynamic memory using standart C functions.
  </p>

  <pre>
#define gmemClear(               P, BYTECOUNT)                                   gmemClearAt(   (P),     (BYTECOUNT),               0)
#define gmemClearType(           P, TYPE)                                        gmemClearAt(   (P),     gsizeof(TYPE),             0)
#define gmemClearTypeAt(         P, TYPE, INDEX)                                 gmemClearAt(   (P),     gsizeof(TYPE),             gsizeof(TYPE) * (INDEX))
#define gmemClearTypeArray(      P, TYPE, COUNT)                                 gmemClearAt(   (P),     gsizeof(TYPE) * (COUNT),   0)
#define gmemClearTypeArrayAt(    P, TYPE, COUNT, INDEX)                          gmemClearAt(   (P),     gsizeof(TYPE) * (COUNT),   gsizeof(TYPE) * (INDEX))

grlAPI void  gmemClearAt(     Gp         * const p,    Gcount const byteCount, Gindex const byteIndex);
</pre>
  <p>
   Given a pointer to a buffer, zero out its memroy.
  </p>
  <p>
   <strong>Type</strong> will specify the size of memory to zero out.  <br />
   <strong>At</strong> will indicate where inside an array of types to zero out.<br />
   <strong>Array</strong> will indicate we will be zeroing out an array of types.
  </p>

  <pre>
#define gmemCopyTypeArray(       P, TYPE, COUNT, INDEX_SRC,    INDEX_DST)        gmemCopy(      (P),     gsizeof(TYPE) * (COUNT),   gsizeof(TYPE) * (INDEX_SRC),  gsizeof(TYPE) * (INDEX_DST))
</pre>
  <p>
   Copying a subset of an array of types, onto itself at a new location.
  </p>

  <pre>
#define gmemCopyOver(            PSRC, BYTECOUNT,              PDST)             gmemCopyOverAt((PSRC),  (BYTECOUNT),               0,                       (PDST),  (Gi) 0)
#define gmemCopyOverType(        PSRC, TYPE,                   PDST)             gmemCopyOverAt((PSRC),  gsizeof(TYPE),             0,                       (PDST),  (Gi) 0)
#define gmemCopyOverTypeArray(   PSRC, TYPE, COUNT,            PDST)             gmemCopyOverAt((PSRC),  gsizeof(TYPE) * (COUNT),   0,                       (PDST),  (Gi) 0)
#define gmemCopyOverTypeArrayAt( PSRC, TYPE, COUNT, INDEX_SRC, PDST, INDEX_DST)  gmemCopyOverAt((PSRC),  gsizeof(TYPE) * (COUNT),   gsizeof(TYPE) * (INDEX_SRC),  (PDST),  gsizeof(TYPE) * (INDEX_DST))

grlAPI Gb    gmemCopy(        Gp         * const p,    Gcount const byteCount, Gindex const byteIndexSrc,                  Gindex const byteIndexDst);
grlAPI Gb    gmemCopyOverAt(  Gp   const * const pSrc, Gcount const byteCount, Gindex const byteIndexSrc, Gp * const pDst, Gindex const byteIndexDst);
</pre>
  <p>
   Copying part of a buffer onto another buffer.  Non-overlapping.  Use gmemCopyTypeArray() if copying into the same buffer.
  </p>

  <pre>
#define gmemCreate(              TYPE_CHAR,  BYTECOUNT)                          gleakCreate((Gp *) gmemCreate_((TYPE_CHAR),    (BYTECOUNT)),                   (BYTECOUNT))
#define gmemCreateType(          TYPE)                                  (TYPE *) gleakCreate((Gp *) gmemCreate_(#TYPE,          gsizeof(TYPE)),           gsizeof(TYPE))
#define gmemCreateTypeArray(     TYPE,       COUNT)                     (TYPE *) gleakCreate((Gp *) gmemCreate_(#TYPE " ARRAY", gsizeof(TYPE) * (COUNT)), gsizeof(TYPE) * (COUNT))

grlAPI Gp   *gmemCreate_(     Char const * const type, Gcount const byteCount);
</pre>
  <p>
   Create a new dynamic memory buffer.  
  </p>
  <p>
   CreateType, and CreateTypeArray are convenience functions for making a buffer of a size of a
   type or a buffer of a size of an array of type.  I use these to reduce tired programmer errors 
   when writing out dynamic memory creation calls.
  </p>
  <p>
   gleak tracking is only done in debug builds.
  </p>

  <pre>
grlAPI void  gmemDestroy(     Gp        * const p);
</pre>
  <p>
   Clean up dynamic memory created by using the gmemCreate*() functions above.  Do not use with
   memCreate, malloc, or calloc calls.
  </p>

  <pre>
#define gmemIsEqual(             PA, PB, COUNT)                                  (memcmp((PA), (PB), (size_t) (COUNT))  == 0)
#define gmemIsEqualType(         PA, PB, TYPE)                                   (memcmp((PA), (PB), sizeof(TYPE))      == 0)
</pre>
  <p>
   wrapper to memcmp functions.
  </p>

  <pre>
grlAPI void  gmemFlushPools(  void);
</pre>
  <p>
   Trim the memory pools.  See description for more information.
  </p>

  <pre>
#define gmemSet(                 P,    BYTECOUNT, BYTEVALUE)                     memset((P), (BYTEVALUE), (size_t) (BYTECOUNT))

grlAPI void  gmemSetDefaced(  Gp        * const p,    Gcount const byteCount);
</pre>
  <p>
   Set the values of the bytes in a buffer.  Defaced will set the values to things like 0xFEEDFACE,
   0xDEADBEEF, etc.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "Gn", "Gn (Natural and 0)");</script>

  <script>HeaderAddType();</script>
  <pre>
typedef uint8_t            Gn1;
typedef uint16_t           Gn2;
typedef uint32_t           Gn4;
typedef uint64_t           Gn8;
</pre>

  <p>
   Or in other words, unsigned integers.
  </p>

  <p>
   As you can see I am using the stdint types.  I believe when I was starting out with GRL it was
   not really common yet and I was using standard C types.  I could be wrong.  But like any other
   library, I define my own types based on memory size.  Instead of bits I use byte count.
  </p>

  <pre>
typedef Gn8                Gn;
</pre>

  <p>
   Same as the above but the numberless versions represent the largest possible representation of
   the type for the platform.  Which may not be the most efficient form for the types.
  </p>

  <pre>
typedef uintptr_t          Gnp;
</pre>

  <p>
   Pointer sized versions of integer and natural.
  </p>

  <pre>
typedef Gn4                Gnh;
</pre>

  <p>
   Half size versions for the platform.
  </p>

  <script>HeaderAddConst();</script>

  <pre>
#define GnMAX                 Gn8MAX

#define Gn1MAX                UINT8_MAX
#define Gn2MAX                UINT16_MAX
#define Gn4MAX                UINT32_MAX
#define Gn8MAX                UINT64_MAX

#define GnpMAX                UINTPTR_MAX
</pre>

  <p>
   The limit constants for these types.  Not complete when it comes to Reals but I have not needed
   the other constants just yet.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "Goffset", "Goffset");</script>

  <script>HeaderAddType();</script>

  <pre>
typedef Gi4                Goffset;
</pre>

  <p>
   A common integer/natural type used in a lot of places.  This will be the most efficient
   size for the platform and currently is an integer and not a natural.  I initially tried a
   natural but for some things, you need negative numbers.  For simplicity I kept it an integer.
   If you end up in a situation where the efficient size integer is not enough range then you will
   have to do something else.
  </p>

  <p>
   Why not just use the raw integer type?  Well, sometimes the type adds to the description of the
   variable/parameter.  In this case, if I have a function that expects an offset then it is clear
   what that variable intends to do.  You may not need to even look at the name of the variable.
   So I use it as a form of making the code more clear.
  </p>

  <script>HeaderAddConst();</script>

  <pre>
#define GoffsetMAX            Gi4MAX
#define GoffsetMIN            Gi4MIN
</pre>

  <p>
   The limit constants for these types.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "Gp", "Gp (void)");</script>

  <script>HeaderAddType();</script>

  <pre>
typedef void               Gp;
</pre>

  <p>
   Why not just use void?  I do use void in places like empty function paramerters, but seeing as
   I have basically redefined everything else, might as well redefine this one as well.  Usually
   never used alone, always used with '*' for a void pointer.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "Gposition", "Gposition");</script>

  <pre>
typedef enum
{
   gpositionSTART   = SEEK_SET,
   gpositionEND     = SEEK_END,
   gpositionCURRENT = SEEK_CUR
} Gposition;
</pre>

  <p>
   A lot of functions need an anchor location for offsetting from.  Using this type to handle those
   situations.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "Gr", "Gr (Real)");</script>

  <script>HeaderAddType();</script>

  <pre>
typedef float              Gr4;
typedef double             Gr8;
</pre>

  <p>
   Different names for standard types just to be complete.
  </p>

  <pre>
typedef Gr8                Gr;
</pre>

  <p>
   Same as the above but the numberless versions represent the largest possible representation of
   the type for the platform.  Which may not be the most efficient form for the types.  I'm
   ignoring long double since it only allows for higher exponents and not higher precision.
  </p>

  <pre>
typedef Gr8                Grp;
</pre>

  <p>
   Pointer sized versions of integer and natural.
  </p>

  <script>HeaderAddConst();</script>

  <pre>
#define GrMAX                 Gr8MAX

#define GrMIN                 Gr8MIN

#define Gr4MAX                FLT_MAX
#define Gr4MIN                FLT_MIN
#define Gr8MAX                DBL_MAX
#define Gr8MIN                DBL_MIN
</pre>

  <p>
   The limit constants for these types.  Not complete when it comes to Reals but I have not needed
   the other constants just yet.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "Gsize", "Gsize");</script>

  <script>HeaderAddType();</script>

  <pre>
typedef Gi4                Gsize;
</pre>

  <p>
   A common integer/natural type used in a lot of places.  This will be the most efficient
   size for the platform and currently is an integer and not a natural.  I initially tried a
   natural but for some things, you need negative numbers.  For simplicity I kept it an integer.
   If you end up in a situation where the efficient size integer is not enough range then you will
   have to do something else.
  </p>

  <p>
   Why not just use the raw integer type?  Well, sometimes the type adds to the description of the
   variable/parameter.  In this case, if I have a function that expects an offset then it is clear
   what that variable intends to do.  You may not need to even look at the name of the variable.
   So I use it as a form of making the code more clear.
  </p>

  <script>HeaderAddConst();</script>

  <pre>
#define GsizeMAX              Gi4MAX
</pre>

  <p>
   The limit constants for these types.
  </p>

  <script>HeaderAddFunc();</script>

  <pre>
#define gsizeIsGood(S)     (0 <= (S))
</pre>

  <p>
   IsGood check for a gsize.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "Gv", "Gv, GvType");</script>

  <pre>
typedef enum
{
   gvTypeNONE,

   gvTypeI,
   gvTypeN,
   gvTypeP,
   gvTypeR,

   gvTypeS,

   gvTypeCOUNT
} GvType;

typedef struct
{
   GvType       type;
   union
   {
      Gip          i;
      Gnp          n;
      Gp          *p;
      Grp          r;
      Gs          *s;
   }            value;
} Gv; //lint !e960 !e9018
</pre>

  <p>
   Gv is more involved than Gvp.  I was using this as variable storage in a scripting language
   that I wrote up.  The type is to identify what actual value is stored in the generic value
   structure.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "Gvp", "Gvp");</script>

  <pre>
typedef union
{
   Gip             i;
   Gnp             n;
   Gp             *p;
   Grp             r;
} Gvp;
</pre>

  <p>
   Generic value structure.  This is assuming, when you use this structure you know what is stored
   inside.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "G_Func", "G*Func");</script>

  <p>
   Various function types for callbacks.
  </p>

  <pre>
typedef Gcompare   (*GrlCompareFunc)(        Gp const * const valueA, Gp const * const valueB);
</pre>
  <p>
   Comparing to items together.<br />



  </p>

  <pre>
typedef void       (*GrlDestroyFunc)(        Gp       * const value);
</pre>
  <p>
   Clean up dynamic memory.<br />



  </p>

  <pre>
typedef void       (*GrlForEachFunc)(        Gp       * const value);
</pre>
  <p>
   Used in a ForEach function call to perform an action on each item.<br />



  </p>

  <pre>
typedef void       (*GrlForEachKeyFunc)(     Gkey const * const key,    Gp       * const value);
</pre>
  <p>
   Used on a ForEach function with a key value container.<br />



  </p>

  <pre>
typedef Gp        *(*GrlForEachProcessFunc)( Gp       * const value);
</pre>
  <p>
   -
  </p>

  <pre>
typedef void       (*GrlForEachAltFunc)(     Gp       * const value, GrlForEachFunc func);
</pre>
  <p>
   -
  </p>

  <pre>
typedef Gp const  *(*GrlGetFunc)(            Gp const * const mem, Gi4 const index);
</pre>
  <p>
   <A form of array/buffer access function.<br />



  </p>

  <pre>
typedef GhashN     (*GrlHashFunc)(           Gp const * const value);
</pre>
  <p>
   Obtain a hash value of something.<br />



  </p>

  <pre>
typedef void       (*GrlSwapFunc)(           Gp       * const mem, Gi4 const indexA, Gi4 const indexB);
</pre>
  <p>
   Swap two values in a form of array/buffer.
  </p>










  <script>UpdateToc();</script>

 </body>
</html>